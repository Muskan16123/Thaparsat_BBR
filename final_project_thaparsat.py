# -*- coding: utf-8 -*-
"""Final_Project_ThaparSat.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13DqXRgXWqzQOW8uuJP1OZ3hOM-XvpcjK
"""

import pandas as pd
import math
import matplotlib.pyplot as plt
import mpmath as mp
import numpy as np
import scipy as sc
from mpl_toolkits import mplot3d
from array import *
from scipy.integrate import *
from matplotlib.ticker import FuncFormatter, MultipleLocator
import sympy as sym

"""**h20_9 file**"""

# values from h20_9 file and related parameters:
E = math.e
PI = math.pi

TEMP_I0 = 5800
TEMP_SOURCE_FUNC = 286.1353
TEMP_E_BBR = 303
TEMP_I3_9 = 301.298

x = 1.19269263e-16
y = 0.0143977322

wavelength_9 = 0.01/2031.40068

def calc_intensity(lamda, temp):
  I = x * (10**-6)/ ((lamda ** 5 ) * (E ** (y/(lamda * temp)) - 1.0))
  return I

I0_9 = calc_intensity(wavelength_9, TEMP_I0)
S_9 = calc_intensity(wavelength_9, TEMP_SOURCE_FUNC)
E_BBR_9 = calc_intensity(wavelength_9, TEMP_E_BBR)
I3_9 = calc_intensity(wavelength_9, TEMP_I3_9)

print(I3_9)
print(wavelength_9)

"""**h2o_3 file**"""

# values from h20_3 file and related parameters:
E = math.e
PI = math.pi

TEMP_I0 = 5800
TEMP_SOURCE_FUNC = 286.1353
TEMP_E_BBR = 303
TEMP_I3_3 = 436.0521

wavelength_3= 0.01/4052

I0_3 = calc_intensity(wavelength_3, TEMP_I0)
S_3 = calc_intensity(wavelength_3, TEMP_SOURCE_FUNC)
E_BBR_3 = calc_intensity(wavelength_3, TEMP_E_BBR)
I3_3 = calc_intensity(wavelength_3, TEMP_I3_3)

print(I3_3)
print(wavelength_3)

"""### **Calculating (tao, alpha) values by Newton Raphson's method.**

Using the above calculated values of I0, S, E_bbr and I3 for both filters of water vapour.
"""

# System of two equations
# Returning a 2x1 array
def F(alpha, tao):
    F0 = (alpha * (I0_9 - S_9) * pow(E, -2 * tao) * 1.0886519179*(10**(-1*5))) + (((alpha * S_9 * 1.0886519179*(10**(-1*5))) + E_BBR_9 - S_9) * (pow(E, -tao))) + S_9 - I3_9
    F1 = (alpha * (I0_3 - S_3) * pow(E, -2 * tao) * 1.0886519179*(10**(-1*5))) + (((alpha * S_3 * 1.0886519179*(10**(-1*5))) + E_BBR_3 - S_3) * (pow(E, -tao))) + S_3 - I3_3
    return np.array([F0, F1])

# The Jacobian matrix:
# Returning a 2x2 array
def dF(alpha, tao):
    J1 = ((I0_9 - S_9) * (pow(E, (-2 * tao)))*1.0886519179*(10**(-1*5)) + (S_9 * 1.0886519179*(10**(-1*5)) * (pow(E, -tao))))
    J2 = (-2 * alpha * (pow(E, -2 * tao) * 1.0886519179*(10**(-1*5)) * (I0_9 - S_9)) - (pow(E, -tao)) * ((alpha * S_9 * 1.0886519179*(10**(-1*5))) + E_BBR_9 - S_9))
    J3 = ((I0_3 - S_3) * (pow(E, (-2 * tao)))*1.0886519179*(10**(-1*5)) + (S_3 * 1.0886519179*(10**(-1*5)) * (pow(E, -tao))))
    J4 = (-2 * alpha * (pow(E, -2 * tao) * 1.0886519179*(10**(-1*5)) * (I0_3 - S_3)) - (pow(E, -tao)) * ((alpha * S_3 * 1.0886519179*(10**(-1*5))) + E_BBR_3 - S_3))
    return np.array([[J1, J2], [J3, J4]], dtype = 'float64')

def Newtons_method(F, dF, x0, y0, tol = 10**-6):
    count = 0
    while count < 50:
        F_val = F(x0, y0)
        J_val = dF(x0, y0)
        d1 = np.linalg.inv(J_val)
        delta = np.dot(d1, F_val)
        x0 -= delta[0]
        y0 -= delta[1]

        if np.linalg.norm(delta) < tol:
            break
        count += 1

    return x0, y0

x = 0.35
y = 0.6

alpha, tao = Newtons_method(F, dF, x, y)
print("alpha =", alpha, "\ntao =", tao)

tao_3 = 0.377295
tao_9 = 0.24627
a_gen = 0.45

tao_avg_value = (tao_3 + tao_9)/2

print("tao_3: ", tao_3)
print("tao_9: ", tao_9)
print("tao_avg: ", tao_avg_value)

# generating random variables around a_gen = 0.45

import random
a_gen_list = []
for i in range(0,200):
 n = random.uniform(0.8,1.2)
 a_gen_list.append(n)

alpha_list=[]
for i in range(0, 200):
  alpha_list.append(a_gen * a_gen_list[i])

print(alpha_list)

# tao random variables list

import random
tao_random = []
for i in range(0,200):
 n = random.uniform(0.8,1.2)
 tao_random.append(n)

print(tao_random)

# tao_3 random variables list

tao_3_list=[]

for i in range(0, 200):
  tao_3_list.append(tao_3 * tao_random[i])

print(tao_3_list)

# tao_9 random variables list

tao_9_list=[]

for i in range(0, 200):
  tao_9_list.append(tao_9 * tao_random[i])

print(tao_9_list)

# average of tao_3 and tao_9 values:

tao_avg = []

for i in range(0, 200):
  tao_avg.append((tao_3_list[i] + tao_9_list[i]) / 2)

print(tao_avg)

# alpha error factor list

alpha_error_fac = []
for i in range(0, 200):
  diff = alpha - alpha_list[i]
  alpha_error_fac.append(abs(diff/alpha_list[i]))

print(alpha_error_fac)

# tao_avg error factor list

tao_avg_error_fac = []
for i in range(0, 200):
  diff = tao_avg_value - tao_avg[i]
  tao_avg_error_fac.append(abs(diff/tao_avg[i]))

print(tao_avg_error_fac)

np_alpha_list = np.array(alpha_list)
np_tao_3_list = np.array(tao_3_list)
np_tao_9_list = np.array(tao_9_list)
np_tao_avg = np.array(tao_avg)
np_alpha_error_fac = np.array(alpha_error_fac)
np_tao_avg_error_fac = np.array(tao_avg_error_fac)

np_stack_map = np.stack((np_alpha_list, np_tao_3_list, np_tao_9_list, np_tao_avg, np_alpha_error_fac, np_tao_avg_error_fac), axis = 1)
pd_stack_map = pd.DataFrame(np_stack_map)

print(pd_stack_map)

pd_stack_map.to_excel('value_for_map.xlsx', sheet_name='sheet1', index=False, header = ['alpha_d', 't3_d', 't9_d', 't_avg_d', 'alpha_ef', 'tao_avg_ef'])

import plotly.express as px
import pandas as pd

# df = pd.read_excel ('newton_raphson_values.xlsx')
df0 = pd.read_excel('value_for_map.xlsx')
df0['alpha, tao'] = df0['alpha_d'].astype(str) + ', ' + df0['t_avg_d'].astype(str)

fig = px.scatter_mapbox (df0,

lon = df0['lng'],
lat = df0['lat'],

zoom = 3,
text = df0['alpha, tao'],

width= 500,
height= 500,

title = 'Reflectance(alpha) and Optical depth(tao) map'
)

fig.update_layout (mapbox_style="open-street-map")
fig.update_layout (margin={"r":0,"t":50,"l":0,"b":10})

fig.show()

# displaying both values:

import pandas as pd
import folium
from IPython.display import display

# Read the data from the Excel sheet
data_file = "value_for_map.xlsx"
df = pd.read_excel(data_file)

# Get the center coordinates for the map
center_lat = df['lat'].mean()
center_lon = df['lng'].mean()

# Create a map object
map_object = folium.Map(location=[center_lat, center_lon], zoom_start=10)

# Define a function to assign colors based on the value (you can modify this based on your specific criteria)
def assign_color(value_a, value_t):
    if value_a <= 0.1 and value_t <=0.1:
        return 'green'
    elif value_a <= 0.23 and value_t <= 0.2:
        return 'orange'
    else:
        return 'red'

# Add markers to the map with colors based on the 'Value' column
# for index, row in df.iterrows():
#     color = assign_color(row['alpha_ef'], row['tao_avg_ef'])
#     folium.Marker(location=[row['lat'], row['lng']], popup= (row['alpha_ef'], row['tao_avg_ef']),
#                   icon=folium.Icon(color=color)).add_to(map_object)
# ...

# Add markers to the map with colors based on the 'Value' column
for index, row in df.iterrows():
    color = assign_color(row['alpha_ef'], row['tao_avg_ef'])
    folium.CircleMarker(location=[row['lat'], row['lng']], radius=5, popup=(row['alpha_ef'], row['tao_avg_ef']),
                        fill=True, fill_color=color, color=color, fill_opacity=0.7).add_to(map_object)

legend_html = '''
     <div style="position: fixed;
                 bottom: 150px; left: 100px; width: 250px; height: 95px;
                 border:2px solid grey; z-index:9999; font-size:14px; color: white; background-color: black;
                 text-align: center; line-height: 1.5; padding: 5px;
                 ">
      <strong>Error factor</strong> <br>
     &nbsp; Green: for both Œ± and  ùúè in 0.0 - 0.1 <br>
     &nbsp; Orange: for both Œ± and ùúè in 0.1 - 0.2<br>
     &nbsp; Red: Rest of the values <br>
      </div>
     '''


map_object.get_root().html.add_child(folium.Element(legend_html))


# Display the map directly in the output console

display(map_object)